<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android通过Navigation组件实现Fragment页面跳转]]></title>
    <url>%2F2018%2F05%2F15%2FAndroid%E9%80%9A%E8%BF%87Navigation%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0navigation%2F</url>
    <content type="text"><![CDATA[前言之前一直想通过一个Activity和多个fragment来实现一个项目，fragment复杂的生命周期使得项目开发的过程中总会遇到各种各样的问题，想要fragment完全替代activity并非易事，并且Fragment的Transaction也没有activity的intent的跳转那么方便快捷。不过， Google为了开发者使用fragment也花费了不少心思，fragment也在不断的完善中。这两年的Google I/O大会也大力宣扬Single Activity multi fragments 的开发方式。 去年推出了Android Architecture Components将Android的开发方式推向了一个新的台阶，将ViewModel和fragment联系起来可以大大简化fragment的生命周期管理，而今年（2018）Google I/O大会中，又在Android Architecture Components中加入了Navigation的组件，以视图（xml配置）的方式管理所有页面（Fragment或Activity）的跳转。 为什么使用Navigation Fragment的Transaction是异步的，通常而言可能是好事，但是可能会产生一些不易察觉的错误，数据竞争等，一些IllegalStateExceptions. 比较难处理Deep Links 传输参数（arguments）更加安全 Navigation的组成 Navigation Graph:Navigation的图示，类似于iOS的storyboard Destinations跳转页，更多时候使用Fragment， 可以添加参数（arguments），行为（actions）和deep link url Host入口Activity，可以将MainActivity仅仅作为app逻辑入口 Actions定义跳转和返回等行为 项目Navigation配置当前AS 3.1版本并没有Navigation的编辑器，下载AS 3.2 Canary预览版才能完美支持Navigation Editor。 添加Navigation依赖123456def versions = [:]versions.navigation = "1.0.0-alpha01"//Navigationimplementation "android.arch.navigation:navigation-runtime:$versions.navigation"implementation "android.arch.navigation:navigation-fragment:$versions.navigation" 然后在res文件夹中navigation目录下创建navigation.xml的文件。 配置activity layoutMainActivity layout需要添加一个NavHostFragment, 提供一个Navigation Controller， 用于管理所有的跳转。 NavHostFragment provides an area within your layout for self-contained navigation to occur. activity_main.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/background_light" tools:context=".ui.MainActivity"&gt; &lt;fragment android:id="@+id/my_nav_host_fragment" android:name="androidx.navigation.fragment.NavHostFragment" android:layout_width="match_parent" android:layout_height="match_parent" app:defaultNavHost="true" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent" app:navGraph="@navigation/navigation" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; app:navGraph=”@navigation/navigation” 添加导航视图xml。 创建Navigation文件(navigation.xml)右键单击res文件夹，在navigation内创建资源文件，创建的文件打开如下： 将其中一个页面设置为初始页面（start destination）,左侧添加Fragment 目标页面，点击目标fragment后，右侧出现属性栏，添加arguments、actions和deep links xml 文件中， text一栏可以用xml配置添加属性，如下：123456789101112131415161718192021&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" app:startDestination="@id/homeFragment"&gt; &lt;fragment android:id="@+id/homeFragment" android:name="com.archiecode.navigationdemo.ui.HomeFragment" android:label="homeFragment" tools:layout="@layout/fragment_home"&gt; &lt;!-- app:destination设置跳转 --&gt; &lt;!-- app:enterAnim 等添加自定义跳转动画 --&gt; &lt;action android:id="@+id/action_home_screen_to_loginFragment" app:destination="@id/loginFragment" app:enterAnim="@anim/slide_in_right" app:exitAnim="@anim/slide_out_left" app:popEnterAnim="@anim/slide_in_left" app:popExitAnim="@anim/slide_out_right" /&gt; &lt;/fragment&gt; &lt;!-- ... --&gt;&lt;/navigation&gt; PS: tools:layout=”@layout/fragment_home” 可以让navgraph显示具体页面 在Fragment点击后的跳转12345rootView.fab.setOnClickListener &#123; //Navigation 是用来获取NavController的工具类，都是些静态方法 //获取NavController实例后，直接调用navigate方法即可，传入action id即可 Navigation.findNavController(rootView).navigate(R.id.action_home_screen_to_loginFragment) &#125; 参数传递没有Navigation之前，我们要在Fragment定义一个newInstance的方法，里面setArguments，着实麻烦，那么Navigation怎么传递参数的呢？有两种方法：1.传统arguments的方法123456rootView.navRegister.setOnClickListener &#123; //定义Bundle 存储参数 val args = bundleOf("email" to rootView.userEdit.text.toString()) //跳转时传入参数 Navigation.findNavController(rootView).navigate(R.id.action_loginFragment_to_registerFragment, args) &#125; 2.safe args（Gradle插件支持） 添加插件build.gradle 123456789apply plugin: 'androidx.navigation.safeargs'#...dependencies &#123; classpath "android.arch.navigation:navigation-safe-args-gradle-plugin:1.0.0-alpha01" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; navGraph中添加参数 1234567&lt;fragment android:id="@+id/confirmationFragment" android:name="com.example.buybuddy.buybuddy.ConfirmationFragment" android:label="fragment_confirmation" tools:layout="@layout/fragment_confirmation"&gt; &lt;argument android:name="amount" android:defaultValue="1" app:type="integer"/&gt;&lt;/fragment&gt; 使用Directions传递参数如HomeFragment会生成一个HomeFragmentDirections，并在目的页面LoginFragment生成LoginFragmentArgs. 1234567891011121314151617//Google Source//send argsoverride fun onClick(v: View?) &#123; val amountTv: EditText = view!!.findViewById(R.id.editTextAmount) val amount = amountTv.text.toString().toInt() val action = SpecifyAmountFragmentDirections.confirmationAction(amount) action.amount = amount v.findNavController().navigate(action)&#125;//......//receive argsoverride fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123; val tv: TextView = view.findViewById(R.id.textViewAmount) val amount = ConfirmationFragmentArgs.fromBundle(arguments).amount tv.text = amount.toString()&#125; 那么类似startActivityForResult的结果回调又是怎么处理呢？目前Navigation组件没有给出相应的办法，我目前的思路，可以使用EventBus进行事件传递，或者如果使用Rxjava，直接封装RxBus进行回调的传递。另外，可以直接使用activity进行回调，使用kotlin会更加方便 123456789101112131415161718192021222324252627282930313233// MainActivity.ktclass MainActivity : AppCompatActivity() &#123; lateinit var onLoginAction: (String) -&gt; Unit lateinit var onRegisterAction: (String) -&gt; Unit override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;&#125;.......//LoginFragment.ktrootView.loginBtn.setOnClickListener &#123; hideSoftkeyboard() toast("登录成功") Navigation.findNavController(rootView).navigateUp() //登陆成功后触发函数block (activity as MainActivity).onLoginAction.invoke(rootView.userEdit.text.toString()) &#125;.......//HomeFragment.ktoverride fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) //登录和注册成功回调到这里 (activity as MainActivity).onLoginAction = &#123; if (it.isNotBlank()) rootView.homeContent.text = it &#125; (activity as MainActivity).onRegisterAction = &#123; if (it.isNotBlank()) rootView.homeContent.text = it &#125; &#125; Deep Links使用Navigation进行Deep Links的跳转也是相当方便的，克服了之前Transaction deep links跳转难的问题。 添加Intent Filter 对于Android Studio 3.2+的用户，直接在Manifest中添加即可123&lt;activity name=".MainActivity"&gt; &lt;nav-graph android:value="@navigation/main_nav" /&gt;&lt;/activity&gt; 总结Google 为了开发者全面使用Fragment也是做了不少努力， 相信今后对于Fragment的支持也会越来越多。 以上代码示例Github(NavigationDemo)]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin使用dagger2的总结]]></title>
    <url>%2F2018%2F02%2F05%2Fkotlin%E4%BD%BF%E7%94%A8dagger2%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[dagger2Android和java的一个快速依赖注入框架，使用它可以让我们写出更加简洁的代码，现在介绍kotlin dagger2的基本使用 gradle添加依赖12345implementation "com.google.dagger:dagger:$dagger_version"implementation "com.google.dagger:dagger-android:$dagger_version"implementation "com.google.dagger:dagger-android-support:$dagger_version"kapt "com.google.dagger:dagger-compiler:$dagger_version"kapt "com.google.dagger:dagger-android-processor:$dagger_version" PS: 需要用到kapt，需要开启kapt，添加插件即可1apply plugin: 'kotlin-kapt' Dagger 2 常用注解的总结 注解 使用 @Module 使用在方法包含 @Provides 注解的类中. @Provides 可以在 @Module 类中的方法名上使用， 该方法提供依赖注入的对象. @Singleton 单例对象. @Component 在接口中使用. Dagger 2 生成所有modules的依赖的代码. Module &amp; Provides 负责提供注入对象1234567891011121314151617181920212223242526272829@Moduleclass DataModule &#123; @Singleton @Provides fun providesOkHttp(preferences: SharedPreferences): OkHttpClient = OkHttpClient.Builder() .addInterceptor(HttpLoggingInterceptor() .apply &#123; level = HttpLoggingInterceptor.Level.BODY &#125;) .addInterceptor &#123; val token = preferences.getString("token", "") val builer: Request.Builder = it.request().newBuilder() if (!token.isNullOrBlank()) &#123; println("token: $token") builer.addHeader("token", token) &#125; builer.addHeader("channel", "android") it.proceed(builer.build()) &#125; .build() @Singleton @Provides fun provideRetrofit(oktHttpClient: OkHttpClient): Retrofit = Retrofit.Builder() .client(oktHttpClient) .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create(Gson())) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build() //......&#125; Component 连接注入器和注入对象123456789101112131415@Singleton@Component(modules = [ AndroidSupportInjectionModule::class, AppModule::class, ActivityModule::class])interface AppComponent: AndroidInjector&lt;MyApp&gt; &#123; @Component.Builder interface Builder &#123; @BindsInstance fun application(application: MyApp): Builder fun build(): AppComponent &#125; override fun inject(app: MyApp)&#125; Multibindings这里我们用AAC（Android Components Architecture）来做示例 1.绑定注解的Key12345@MustBeDocumented@Target(AnnotationTarget.FUNCTION)@Retention(AnnotationRetention.RUNTIME)@MapKeyinternal annotation class ViewModelKey(val value: KClass&lt;out ViewModel&gt;) 2.绑定具体实例到Map中12345678@Moduleabstract class ViewModelModule &#123; @Binds @IntoMap @ViewModelKey(LoginViewModel::class) abstract fun bindLoginViewModel(viewModel: LoginViewModel): ViewModel //......&#125; 3.注入获取依赖Map， 有必要创建一个工厂类12345678910111213141516171819202122class ViewModelFactory @Inject constructor(private val creators: Map&lt;Class&lt;out ViewModel&gt;, @JvmSuppressWildcards Provider&lt;ViewModel&gt;&gt;) : ViewModelProvider.Factory &#123; @Suppress("UNCHECKED_CAST") override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123; var creator: Provider&lt;ViewModel&gt;? = creators[modelClass] if (creator == null) &#123; for ((key, value) in creators) &#123; if (modelClass.isAssignableFrom(key)) &#123; creator = value break &#125; &#125; &#125; if (creator == null) throw IllegalArgumentException("unknown model class " + modelClass) try &#123; return creator.get() as T &#125; catch (e: Exception) &#123; throw RuntimeException(e) &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google bbr tcp加速]]></title>
    <url>%2F2018%2F01%2F05%2FGoogle%20bbr%20tcp%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[最近Linode使用了Google bbr的加速Shadowsocks， 感觉效果还是挺明显的， 在Ubuntu上开启也比较方便。下面介绍下安装及开启过程。 安装 BBR 一键安装脚本：系统支持：CentOS 6+，Debian 7+，Ubuntu 12+123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 查看安装状态12sysctl net.ipv4.tcp_available_congestion_controllsmod | grep bbr]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux初探]]></title>
    <url>%2F2016%2F11%2F15%2FRedux%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[Redux 简介单页面app变得更加复杂之后，需要进行处理更多的页面状态，管理这些状态会使得app代码结构变得臃肿甚至有些混乱，facebook的开源项目中，推荐使用flux管理客户端网页项目，从而改善项目的数据流。由此发展的Redux越来越受开发者欢迎，其使用的函数式编程的思想使得很多问题得到简化。不像flux的是，Redux没有Dispatcher的概念，由于redux更多是依赖于纯粹的函数而不是事件的分发。熟悉函数式编程的应该清楚，函数之间可以更好的组合(Compose)，而无需额外的实体类来管理。Redux和Flux另外一个重要的不同点是，Redux是鼓励数据的不变性(Imutable)，不希望在reduces中改变对象或者数组，而是新建另外的对象或使用Imutable的库(Library)。 Data Flow使用flux或redux的数据流，是的数据流只能单向流动，每个store只能随action的改变而改变，其它的都无法影响它。一个简单的例子： a).用户按下button A; b).button A 的操作分发了一个action, 并引起了store的变化； c).其它所有的action都能通知其对应的store,所以store B 也能对相同的action作出相应的反应； d).store A 和 store B 的改变通知View B 变化，然后刷新。 Action Creatoraction creator 实际上就是一个函数 var actionCreator = function() { return { type: ‘AN_ACTION’ }} 就是这么简单，当然你可以使用更多的property来传输你想要的数据。 console.log(actionCreator);//output: { type: ‘AN_ACTION’ } Reducer| Redux is a “predictable state container for javaScript apps”. reducer vs store 在flux 架构中我们有一个”Store”, 而不是redux所称之为的”Reducer”, 它们的区别是什么呢？ 很明显的是，store能够保存你的数据，而reducer并不能．在传统的flux中，stores保持他们的state，而在redux, 每次reducer调用，传输的需要更新的状态．这种方式下，redux的store变成了”无状态的存储(stateless stores)”, 而且被命名为reducers．]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React基础]]></title>
    <url>%2F2016%2F11%2F04%2FReact%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[为什么使用React.js?随着移动端的发展，前端的设计要求也变得比较高了，更加注重页面的交互和体验。技术的要求也随之提高，react 和 angular 正是借着这个东风发展起来。facebook 开源的react 让H5页面View 的编写有了更多的选择，也让前端的技术含量提升了一个档次。为什么选择React? 官方的解释称： We built React to solve one problem: building large applications with data that changes over time. 即为了建立大型的动态网页; 而从技术层面上讲，随着React Native 的开源，移动平台也可以使用React编写应用，并可以接近原生应用的性能体验, 正实现着 LEARN ONCE, WRITE ANYWHERE. 换而言之，React让web/Android平台/iOS平台的开发界限越来越小，一个前端的开发人员即可完成三个平台的应用开发. 背景国内的互联网技术相比墙外的技术总是落后一拍的，国内多数老旧项目一般暂时不会改变View的架构，而新建的项目倒是不少公司已经拿来试试水．React Native的开源更是让这股潮流势不可挡, 让Web和移动平台的交互的共通点越来越多。就国内移动应用而已，QQ/QQ空间/QQ音乐/手机百度/淘宝客户端 等相对大型的移动应用均完成了React 相应的改造. 知识预备require optionjavascript, html基础 reduxes6语法 webpack 内容实践几个关键概念JSXReact为了简化而推出的一种类似xml的语法,用于编写DOM结构。跟xml一样，JSX 同样拥有标签(tag)/属性(attributes)/子类(children),React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。class和for为js关键字，因此React DOM 用className 和 htmlFor做对应属性。 JSX Example12345678910class Hello extends React.Component &#123; render() &#123; return ( &lt;div className="container"&gt; &lt;p&gt;Hello this.props.name&lt;/p&gt; &lt;/div&gt; ); &#125; &#125;ReactDOM.render(&lt;Hello name="world"/&gt;, document.getElementById("hello")); ComponentsReact的设计思想就是将UI分割成各个组件，每个组件处理各自的数据，包括状态数据和属性数据。组件之间可以互相组合，组件之间可以存在从属关系。组件中存在state和props，用于传递数据、更新组件。 state - 组件的内部状态props - 组件的外部状态 值得注意的是，父组件可以读取子组件的props. this.props.children 。而this.state是可以在render传递过程中保持数据的。在动态子组件中，为了过滤相应的组件可以指定子组件的key。 1234567891011121314151617181920212223242526272829303132333435import React from 'react';import ReactDOM from 'react-dom';class ListItem extends React.Component &#123; render() &#123; return &lt;li&gt;&#123;this.props.data.name&#125;&lt;/li&gt; &#125;&#125;class MyList extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123;this.props.results.map((result) =&gt; ( &lt;ListItem key=&#123;result.id&#125; data=&#123;result.data&#125; /&gt; ))&#125; &lt;/ul&gt; ); &#125;&#125;const RESULTS = [&#123; id: 100, data: &#123; name:"ZHOUJIELUN", age:37, &#125;&#125;,&#123; id: 101, data: &#123; name:"CHENYIXUN", age:42, &#125;&#125;,]ReactDOM.render(&lt;MyList results=&#123;RESULTS&#125; /&gt;,document.getElementById("list")); PS:(key应该直接指定于数组内的组件，而不是html标签内) 代码书写组件的时候，要尽量考虑组件的复用性，这样在写UI的时候可以大大减少代码量。所以更多的时候还得增加组件代码的健壮性，比如 对Props的数据类型进行规定;使用React.PropTypes.element可以把子组件当做数据进行传递。指定Props的默认值。如果该组件无状态值，完全可以用一个函数替代组件类。PropTypes1234567891011MyComponent.propTypes = &#123; name: React.PropTypes.string, age: React.PropTypes.number, ...&#125;Stateless Functionsconst Checking = (props) =&gt; &#123; return &lt;h3&gt;Checking...&#123;props.progress&#125;&lt;/h3&gt; &#125;;ReactDOM.render(&lt;Checking progress="45" /&gt;,document.getElementById("check")); Actions组件行为组件存在着自己的行为,也可以看做是组件的生命周期(lifecircle)。从源码中的ReactClassInterface接口中,可以看到 ReactClassInterface12345678910...getInitialState: SpecPolicy.DEFINE_MANY_MERGED,render: SpecPolicy.DEFINE_ONCE,componentWillMount: SpecPolicy.DEFINE_MANY, componentDidMount: SpecPolicy.DEFINE_MANY,shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,componentWillUpdate: SpecPolicy.DEFINE_MANY,componentWillUnmount: SpecPolicy.DEFINE_MANY, updateComponent: SpecPolicy.OVERRIDE_BASE,... 可以归结为以下行为： mount - 将组件加载进入DOMinitialize - 在组件加载之前，通常进行初始化stateupdate - state(或props)的变化导致UI组件的刷新render - 使用props 和state 将组件进行展示的过程destroy - 和initialize的过程相反信息的载体广义上讲，Actions 作为从应用程序中往store中发送数据的载体，他们是store 信息的唯一来源。Actions只是描述了事情的发生。但是不指定应用程序状态改变时，如何更改响应。因而很多时候，数据流若想做到有条不紊的处理，我们就需要Flux或着Redux帮助我们处理，特别是一个应用中，单页面需要处理大量的状态的时候，Redux就变得很有必要了。篇幅有限，Redux以后再深入讨论。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
</search>
